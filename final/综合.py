from langchain.memory import ConversationBufferMemoryfrom langchain_text_splitters import RecursiveCharacterTextSplitterfrom langchain.vectorstores import Chromafrom PyQt5.QtWidgets import (QApplication, QMainWindow, QVBoxLayout,                             QPushButton, QTextEdit, QWidget, QLabel,                             QDialog, QFileDialog)from PyQt5.QtCore import Qt, pyqtSignal, QThread, pyqtSignalfrom PyQt5.QtGui import QFontimport time, randomimport sysimport osimport tracebackfrom typing import List, Tuplefrom funcs.password2 import embeddings, llmfrom langchain_text_splitters import RecursiveCharacterTextSplitterfrom langchain.memory import ConversationBufferMemorytry:    from langchain_chroma import Chromaexcept Exception:    from langchain_community.vectorstores import Chromaclass Info:    def __init__(self, data_path='../database',                 history_path='../history',                 embed=embeddings):        self.embed = embed        self.data_path = os.path.abspath(data_path)# [修改] 统一绝对路径        self.history_path = os.path.abspath(history_path)        self.collection = "langchain"  # 显式集合名        # 显式 collection_name        self.db = Chroma(persist_directory=self.data_path,                         collection_name=self.collection,                         embedding_function=self.embed,                         collection_metadata={"hnsw:space":"cosine"}                         )        print("[DEBUG] data_path   =", self.data_path)        try:            meta = self.db._collection.get().get("metadata",{})            print("[DEBUG] collection =", self.collection)            print("[DEBUG] hnsw:space =", meta.get("hnsw:space"))            print("[DEBUG] doc_chunks =", self.db._collection.count())        except Exception as e:            print("[DEBUG] meta-read error:=",e)        self.history, self.memory = self.load_history()    def generate(self, documents):        text_splitter = (            RecursiveCharacterTextSplitter(chunk_size=450,                chunk_overlap=50, length_function=len))        # 拆句切片        res: list[str] = []        for sentence in documents:            if len(sentence) <= 450:                res.append(sentence)            else:                res.extend(text_splitter.split_text(sentence))        # 初始化空的 Chroma 数据库        self.db = Chroma(persist_directory=self.data_path,                         collection_name=self.collection,                         embedding_function=self.embed,                         collection_metadata={"hnsw:space":"cosine"})        # 分批写入，每批最多 256 条        batch_size = 64        max_retries = 5        for offset in range(0, len(res), batch_size):            chunk = res[offset:offset + batch_size]            for attempt in range(max_retries):                try:                    # 正确做法：直接让 Chroma 用 embedding_function 计算向量                    self.db.add_texts(chunk)                    break                except Exception as e:                    msg = str(e)                    if ('TooManyRequests' in msg or                            'ServerOverloaded' in msg):                        wait = (2 ** attempt) + random.random()                        print(                            f"[重试] 第 {attempt + 1} 次失败，{wait:.1f}s "                            f"后重试…")                        time.sleep(wait)                        continue                    # 其他异常直接抛出                    raise            else:                # 重试用尽仍失败                raise RuntimeError(                    f"重试 {max_retries} 次后，第 {offset} 条 chunk 仍失败")        print("[build] collection count:",              getattr(self.db, "_collection",None).count()                if hasattr(self.db,"_collection") else "N/A")    def show_result(self, query, number=2):        results = (            self.db.similarity_search_with_relevance_scores(query,                k=number))        i = 1        for res in results:            print(f'第{i}个结果：')            print(f'相似得分：{res[1]:.4f}')            print(f'文档内容：{res[0].page_content}')            i += 1    def get_documents(self, number=3):        return self.db.get()['documents'][-number:]    def show_documents(self, number=3):        for doc in self.get_documents(number):            print(doc)    def load_history(self):        history = Chroma(persist_directory=self.history_path,                         collection_name = f"{self.collection}_history",#fix history                         embedding_function=self.embed,                         collection_metadata={"hnsw:space":"cosine"})        try:            meta = history._collection.get().get("metadata",{})            print("[DEBUG] history hnsw:space =", meta.get("hnsw:space"))            print("[DEBUG] history chunks     =", history._collection.count())        except Exception as e:            print("[DEBUG] history meta-read error:", e)        memory = ConversationBufferMemory(return_messages=True)        return history,memory    def get_history(self, number=3):        return self.memory.buffer[-number:]    def show_history(self, number=3):        for idx, dialogue in enumerate(self.get_history(number)):            print(idx, dialogue.content)    def save_history(self, query, answer):        text = f'用户问题：{query}'        metadata = {'ai答案': answer}        self.history.add_texts([text],metadatas=[metadata])class Model:    def __init__(self, info, history_path='../history',                 embed=embeddings, llm=llm):        self.info = info        self.db = info.db        self.history, self.memory = info.load_history()        self.path = history_path        self.embed = embed        self.llm = llm    def check(self, query, threshold=0.7):        results = (            self.history.similarity_search_with_relevance_scores(                query, k=1))        if results and results[0][1] > threshold:            res = f'已经检索到相关的历史记录，直接返回。\n'            res += results[0][0].metadata['ai答案']        else:            res = None        return res    def infer(self, query, number=2, throshold=0.65):        res = self.check(query)        if res:            return res        results = self.db.similarity_search_with_relevance_scores(            query, k=number)        results = [r for r in results if                   r[1] >= throshold]        if results:            context = '\n'.join(result[0].page_content for result in results)            res = f'已经检索到相关文档，按照文档内容生成。\n'        else:            context = ''            res = f'没有检索到相关的文档，直接使用模型进行推理。\n'            try:                probe = self.db.similarity_search_with_relevance_scores(query,k=1)                if probe:                    print(f"[bebug] top1 relevance={probe[0][1]:.3f}(threshold={throshold})")            except Exception as e:                print(f"[bdbug] probe error:{e}")        prompt_template = '''        现在你是一个资深的人工智能讲师，请根据以下文档，回答问题：        {context}        输出格式如下：        问题：{query}        答案：        禁止生成markdown格式的内容        '''        prompt = prompt_template.format(context=context, query=query)        response = llm.invoke(prompt)        self.info.save_history(query, response)        return res + response    def rebuild_from_txt(self,txt_path="面试题集.txt"):        with open(txt_path,"r",encoding="utf-8") as f:            full = f.read()        splitter = RecursiveCharacterTextSplitter(            separators=["\n\n", "\n", "。", "！", "？", "，", " ", ""],            chunk_size=1000,            chunk_overlap=150,        )        chunks = splitter.split_text(full)        self.db = Chroma(            persist_directory=self.data_path,            collection_name=self.collection,            embedding_function=self.embed,            collection_metadata={"hnsw:space":"cosine"}        )        self.db.add_texts(chunks)        try:            print("[build] collection count:",self.db._collection.count())        except Exception:            passclass MainWindow(QMainWindow):    def __init__(self, info=Info()):        super().__init__()        self.info = info        self.model = Model(self.info)        self.setWindowTitle('AI助学系统')        self.setGeometry(100, 100, 1600, 900)        self.display_area = QTextEdit(self)        self.display_area.setReadOnly(True)        self.display_area.setGeometry(0, 10, 1600, 500)        self.display_area.setFont(QFont('Helvetica', 36))        self.input_field = QTextEdit(self)        self.input_field.setGeometry(0, 520, 1600, 300)        self.input_field.setPlaceholderText('请输入你的问题')        self.input_field.setFont(QFont('Helvetica', 36))        self.display_area.append('欢迎使用AI助学系统')        self.display_area.append('请输入要推理的问题')        self.display_area.append('-' * 50)        self.inference_button = QPushButton('开始推理', self)        self.inference_button.setGeometry(50, 830, 1500, 30)        self.inference_button.clicked.connect(self.start_inference)        self.database_button = QPushButton('数据库管理', self)        self.database_button.setGeometry(50, 870, 1500, 30)        self.database_button.clicked.connect(            self.open_database_window)    def start_inference(self):        query = self.input_field.toPlainText()        self.input_field.clear()        if not query:            self.display_area.append('请添加要推理的内容')            return        self.display_area.append(f'推理问题是：\n{query}')        self.display_area.append(f'问题正在推理中...')        res = self.model.infer(query)        self.display_area.append(f'模型的答案：\n{res}')    def open_database_window(self):        self.database_window = DatabaseWindow(self.info)        self.database_window.message.connect(self.recieve_message)        self.database_window.show()    def recieve_message(self, msg):        self.display_area.append(msg)        self.display_area.append(f'\n')class GenerateDatabaseWorker(QThread):    # 运行结束后发出提示消息    finished = pyqtSignal(str)    def __init__(self, info, documents):        super().__init__()        self.info = info        self.documents = documents    def run(self):        try:            self.info.generate(self.documents)            self.finished.emit("数据库已经加载成功")        except Exception as e:            self.finished.emit(f"数据库加载失败：{e}")class DatabaseWindow(QWidget):    message = pyqtSignal(str)    def __init__(self, info):        super().__init__()        self.info = info        self.setWindowTitle('数据库管理')        self.resize(500, 200)        layout = QVBoxLayout()        self.label = QLabel('数据库管理', self)        self.label.setAlignment(Qt.AlignCenter)        self.generate_button = QPushButton('重新生成数据库', self)        self.generate_button.clicked.connect(self.generate_database)        self.show_documents_button = QPushButton('显示数据库的文档',                                                 self)        self.show_documents_button.clicked.connect(            self.show_documents)        self.show_history_button = QPushButton('显示历史记录', self)        self.show_history_button.clicked.connect(self.show_history)        self.back_button = QPushButton('返回主界面', self)        self.back_button.clicked.connect(self.close_window)        layout.addWidget(self.label)        layout.addWidget(self.generate_button)        layout.addWidget(self.show_documents_button)        layout.addWidget(self.show_history_button)        layout.addWidget(self.back_button)        self.setLayout(layout)    def show_message(self, msg):        dialog = QDialog(self)        dialog.setWindowTitle('消息提示')        dialog.resize(300, 100)        label = QLabel(msg, dialog)        label.move(80, 40)        dialog.exec_()    def generate_database(self):        self.message.emit(f'数据库的位置：{self.info.data_path}')        self.message.emit(f'历史记录的位置：{self.info.history_path}')        file_path, _ = QFileDialog.getOpenFileName(caption='选择文档',                                                   directory='./',                                                   filter='文本文件(*)')        if not file_path:            return self.show_message("未选择任何文件")            # 读取文档（很快，不会卡顿）        try:            with open(file_path, 'r', encoding='utf-8') as f:                documents = eval(f.read())        except UnicodeError:            with open(file_path, 'r', encoding='gbk') as f:                documents = eval(f.read())        self.generate_button.setEnabled(False)        self.worker = GenerateDatabaseWorker(self.info, documents)        self.worker.finished.connect(self.on_generate_finished)        self.worker.start()    def on_generate_finished(self, msg):        # 后台完成后恢复按钮并弹提示        self.generate_button.setEnabled(True)        self.show_message(msg)    def show_documents(self):        res = self.info.get_documents(5)        self.message.emit(f'数据库的文档如下：')        for document in res:            self.message.emit(f'{document}')    def show_history(self):        res = self.info.get_history()        self.message.emit(f'历史记录如下：')        for idx, dialog in enumerate(res):            self.message.emit(                f'第{idx + 1}条历史记录：\n{dialog.content}')    def close_window(self):        self.close()if __name__ == '__main__':    app = QApplication(sys.argv)    window = MainWindow()    window.show()    app.exec_()